--- a/collage.js
+++ b/collage.js
@@ -63,7 +63,10 @@ function makeStrips(R, photoQueue, p, W, H, maxElemArea) {
   while (strips.length < count && tries < count*40) {
     tries++;
     const angle = sampleAngle(R, p.strips.angleMin);
     const thickness = (p.strips.thicknessPct/100) * Math.min(W, H);
-    const opacity = clamp((p.strips.opacityPct/100), 0.76, 1.0);
+    // Add slight variation in strip opacity
+    const baseOpacity = clamp(p.strips.opacityPct / 100, 0.6, 1.0);
+    const opacity = clamp(baseOpacity + R.range(-0.25, 0.15), 0.08, 1.0);
+
     const photo = photoQueue.next();
@@ -160,9 +163,12 @@ function makeTiles(R, photoQueue, p, W, H, maxElemArea, N, clusters) {
     const src = chooseCoverSample(img, bbox.w, bbox.h, R, { scale, overscan: 1.15 });

     const tile = {
       kind: 'tile',
-      type, poly, angle, skew, opacity: 1.0,
+      type, poly, angle, skew,
+      // Add subtle variation in tile opacity
+      opacity: clamp(0.85 + R.range(-0.45, 0.15), 0.08, 1.0),
       src: src, blend: 'source-over'
     };
     tiles.push(tile);
@@ -243,7 +249,15 @@ function drawTile(ctx, t) {
   ctx.clip();
   const b = polygonBBox(t.poly);
-  drawImageCover(ctx, t.src.img, b.x, b.y, b.w, b.h, t.src);
+  // Rotate image content with tile angle
+  ctx.save();
+  ctx.translate(b.x + b.w / 2, b.y + b.h / 2);
+  ctx.rotate(t.angle || 0);
+  drawImageCover(ctx, t.src.img, -b.w / 2, -b.h / 2, b.w, b.h, t.src);
+  ctx.restore();

   // Optional stroke for non-rect shapes
   if (t.type !== 'rect') {
     ctx.save();
     ctx.beginPath();
     ctx.moveTo(t.poly[0].x, t.poly[0].y);
     for (let i = 1; i < t.poly.length; i++) ctx.lineTo(t.poly[i].x, t.poly[i].y);
     ctx.closePath();
     ctx.lineWidth = Math.max(1, Math.min(b.w, b.h) * 0.006);
     ctx.strokeStyle = 'rgba(0,0,0,0.55)';
     ctx.stroke();
     ctx.globalCompositeOperation = 'overlay';
     ctx.strokeStyle = 'rgba(255,255,255,0.25)';
     ctx.stroke();
     ctx.globalCompositeOperation = 'source-over';
     ctx.restore();
   }
@@ -328,7 +342,10 @@ function makeScissorPoly(w,h,jag,R,N) {
   const density = 6 + Math.floor(jag/8);
   edges.forEach(([a,b], ei) => {
     for (let i=0;i<=density;i++){
       const t=i/density;
       const x=a[0]+(b[0]-a[0])*t;
       const y=a[1]+(b[1]-a[1])*t;
       const nx = (ei===0||ei===2)? 0 : (ei===1?1:-1);
       const ny = (ei===0? -1 : ei===2?1:0);
-      const amp = (w+h)*0.006*(0.5 + jag/100);
+      const amp = (w+h)*0.012*(0.5 + jag/100); // Rougher edges
       const n = (N(x*0.03, y*0.03)-0.5)*2;
       pts.push({x:x + nx*amp*(0.5+Math.abs(n)), y:y + ny*amp*(0.5+Math.abs(n))});
     }
   });
@@ -344,7 +361,8 @@ function makeTornPoly(w,h,rough,R,N) {
     const n = (N(x*0.015+100, y*0.015+100)-0.5)*2;
-    const amp = (w+h)*0.02*(rough/100);
+    const amp = (w+h)*0.028*(rough/100); // More aggressive tear
     x += Math.cos(ang) * n * amp;
     y += Math.sin(ang) * n * amp;
     pts.push({x,y});
   }
@@ -190,7 +190,10 @@ function makeClusters(R, photoQueue, p, W, H, maxElemArea, N) {
   const count = clampInt(p.clusters.count, 0, 20);
   const per = clampInt(p.clusters.tilesPer, 1, 50);
-  const opacity = clamp(p.clusters.opacityPct/100, 0.76, 1.0);
+  // Allow slightly more range
+  const opacity = clamp(p.clusters.opacityPct/100 + R.range(-0.25, 0.1), 0.5, 1.0);

   const clusters = [];
   let tries = 0;
   while (clusters.length < count && tries < count*30) {
     tries++;
     const cx = R.range(0.2*W, 0.8*W);
     const cy = R.range(0.2*H, 0.8*H);
-    const radius = Math.min(W,H) * 0.18 * (0.8 + R()*0.4);
+    const radius = Math.min(W,H) * 0.15 * (0.6 + R()*0.4); // slightly smaller spread
