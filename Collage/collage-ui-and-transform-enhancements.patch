diff --git a/Collage/app.js b/Collage/app.js
--- a/Collage/app.js
+++ b/Collage/app.js
@@ -1,6 +1,183 @@
 // UI wiring, ribbon modes, image loading, render/export, and batch.
 // Requires collage.js for generateCollage().
 
+/* ==== Enhanced controls: dual inputs + sensitivity curves for ALL sliders ==== */
+const $ = (id) => document.getElementById(id);
+const q = (sel, el = document) => el.querySelector(sel);
+const qa = (sel, el = document) => Array.from(el.querySelectorAll(sel));
+
+// Control map: every slider in index.html with generous numeric ranges and tuned curves
+// Curve helpers boost mid-range sensitivity; numbers can push beyond slider bounds.
+const CONTROL_MAP = {
+  // Negative space & limits
+  negSpace:   { numMin: 0,   numMax: 95,  curve: v => curveExpo(v, 10, 70, 0.62) },
+  maxElem:    { numMin: 1,   numMax: 60,  curve: v => curveExpo(v, 5, 30, 0.55) },
+
+  // Tiles
+  tileCount:  { numMin: 10,  numMax: 240, curve: v => curveExpo(v, 42, 96, 0.48), integer: true },
+  specialPct: { numMin: 0,   numMax: 100, curve: v => curveExpo(v, 10, 60, 0.55) },
+  sizeMean:   { numMin: 0.5, numMax: 20,  curve: v => curveExpo(v, 1, 6, 0.55) },
+  sizeSpread: { numMin: 0.5, numMax: 30,  curve: v => curveExpo(v, 1, 8, 0.50) },
+  rotRange:   { numMin: 0,   numMax: 180, curve: v => curveExpo(v, 5, 75, 0.40) },
+  skewRange:  { numMin: 0,   numMax: 80,  curve: v => curveExpo(v, 0, 20, 0.42) },
+  scissorJag: { numMin: 0,   numMax: 200, curve: v => curveExpo(v, 0, 100, 0.60) },
+  tornRough:  { numMin: 0,   numMax: 200, curve: v => curveExpo(v, 0, 100, 0.60) },
+
+  // Strips
+  stripCount:   { numMin: 0,  numMax: 60,  curve: v => curveExpo(v, 0, 20, 0.52), integer: true },
+  stripThick:   { numMin: 0.2,numMax: 40,  curve: v => curveExpo(v, 1, 15, 0.50) },
+  stripOpacity: { numMin: 10, numMax: 100, curve: v => curveExpo(v, 76, 100, 0.70) },
+  angleMin:     { numMin: 0,  numMax: 60,  curve: v => curveExpo(v, 10, 30, 0.55) },
+
+  // Clusters
+  clusterCount:   { numMin: 0,  numMax: 20, curve: v => curveExpo(v, 0, 9, 0.55), integer: true },
+  clusterTiles:   { numMin: 1,  numMax: 40, curve: v => curveExpo(v, 5, 17, 0.55), integer: true },
+  clusterOpacity: { numMin: 10, numMax: 100,curve: v => curveExpo(v, 76, 100, 0.70) },
+
+  // Easter eggs
+  eggCount: { numMin: 0,   numMax: 30, curve: v => curveExpo(v, 0, 7, 0.55), integer: true },
+  eggSize:  { numMin: 0.05,numMax: 10, curve: v => curveExpo(v, 0.2, 3, 0.48), stepHint: 0.1 },
+};
+
+// Exponential-ish curve that boosts low/mid sensitivity.
+// Input v in [a,b]; k in (0,1). Smaller k = stronger boost.
+function curveExpo(v, a, b, k) {
+  const t = (v - a) / (b - a);
+  const t2 = Math.pow(Math.max(0, Math.min(1, t)), k);
+  return a + t2 * (b - a);
+}
+
+// Adds number inputs next to sliders, stronger curves, and Shift-drag fine control.
+function enhanceSliders() {
+  Object.keys(CONTROL_MAP).forEach(id => {
+    const slider = $(id);
+    if (!slider || slider.tagName !== 'INPUT' || slider.type !== 'range') return;
+    if (slider.__enhanced) return;
+
+    const cfg = CONTROL_MAP[id];
+    const wrapper = slider.closest('.param') || slider.parentElement;
+
+    // Create number input
+    const num = document.createElement('input');
+    num.type = 'number';
+    num.className = 'paired-number';
+    num.style.marginLeft = '8px';
+    num.style.width = '84px';
+    const sliderStep = slider.step && slider.step !== '' ? parseFloat(slider.step) : 1;
+    const numStep = cfg.stepHint || sliderStep || 1;
+    num.step = String(numStep);
+
+    // Allow numbers to exceed slider bounds
+    const sMin = slider.min !== '' ? +slider.min : 0;
+    const sMax = slider.max !== '' ? +slider.max : 100;
+    num.min = (cfg.numMin != null ? cfg.numMin : sMin).toString();
+    num.max = (cfg.numMax != null ? cfg.numMax : Math.max(sMax, sMin)).toString();
+    num.value = slider.value;
+
+    wrapper.appendChild(num);
+
+    const format = (x) => {
+      if (cfg.integer) return String(Math.round(x));
+      const stepStr = String(num.step);
+      const dp = stepStr.includes('.') ? (stepStr.split('.')[1].length) : 0;
+      return String(Number(x).toFixed(dp));
+    };
+
+    const syncFromSlider = (trigger=true) => {
+      const raw = +slider.value;
+      const curved = cfg.curve ? cfg.curve(raw) : raw;
+      num.value = format(curved);
+      if (trigger) requestRenderSoon();
+    };
+    const syncFromNumber = (trigger=true) => {
+      let v = +num.value;
+      if (cfg.integer) v = Math.round(v);
+      // Keep the slider within its visual span so UI feels stable
+      if (v < +slider.min) slider.value = String(slider.min);
+      else if (v > +slider.max) slider.value = String(slider.max);
+      else slider.value = String(v);
+      if (trigger) requestRenderSoon();
+    };
+
+    // Default change
+    slider.addEventListener('input', () => syncFromSlider(true));
+    // Shift-drag for fine control
+    slider.addEventListener('pointerdown', (e) => {
+      if (!e.isPrimary) return;
+      const baseStep = sliderStep || 1;
+      const fineStep = baseStep * 0.1;
+      let lastX = e.clientX;
+      let val = +slider.value;
+      const onMove = (ev) => {
+        const dx = ev.clientX - lastX;
+        lastX = ev.clientX;
+        const useFine = ev.shiftKey;
+        const delta = (dx / 4) * (useFine ? fineStep : baseStep);
+        val = clamp(val + delta, +slider.min, +slider.max);
+        if (cfg.integer) val = Math.round(val);
+        slider.value = String(val);
+        syncFromSlider(true);
+      };
+      const off = () => {
+        window.removeEventListener('pointermove', onMove);
+        window.removeEventListener('pointerup', off);
+      };
+      window.addEventListener('pointermove', onMove);
+      window.addEventListener('pointerup', off);
+    });
+
+    num.addEventListener('change', () => syncFromNumber(true));
+    num.addEventListener('input', () => {/* avoid render spam while typing */});
+
+    // Initialize number view
+    syncFromSlider(false);
+
+    slider.__enhanced = { num, cfg, syncFromSlider, syncFromNumber };
+  });
+}
+
+// Compute effective param from enhanced controls (prefers curved numeric)
+function readEnhanced(id, fallback) {
+  const el = $(id);
+  if (!el) return fallback;
+  const enh = el.__enhanced;
+  if (!enh) return +el.value;
+  return +enh.num.value;
+}
+
+// Debounced render requests to keep UI smooth during scrubbing/typing
+let __renderTimer = null;
+function requestRenderSoon(ms = 60) {
+  clearTimeout(__renderTimer);
+  __renderTimer = setTimeout(() => run(false), ms);
+}
@@ -96,7 +273,8 @@ function bindUI() {
   $('file').addEventListener('change', onFiles);
+  qa('[data-action]').forEach(btn => btn.addEventListener('click', onAction));
+  enhanceSliders();
 
+  // Build enhanced slider+number controls for all mapped sliders
+  enhanceSliders();
@@ -338,3 +511,12 @@ function sanitizeFilename(name) {
   return name.replace(/[^\w\-\.]+/g, '_').slice(0, 80);
 }
+
+
+/* CSS hint:
+   .paired-number { width: 84px; }
+*/
diff --git a/Collage/app.css b/Collage/app.css
--- a/Collage/app.css
+++ b/Collage/app.css
@@ ... @@
+/* Optional for enhanced number input */
+.paired-number { width: 84px; }
diff --git a/Collage/collage.js b/Collage/collage.js
@@ ... @@
+// ------ Matrix helpers for image-space transforms ------
+function matIdentity(){ return [1,0,0,1,0,0]; }
+function matMultiply(a,b){
+  return [
+    a[0]*b[0] + a[2]*b[1],
+    a[1]*b[0] + a[3]*b[1],
+    a[0]*b[2] + a[2]*b[3],
+    a[1]*b[2] + a[3]*b[3],
+    a[0]*b[4] + a[2]*b[5] + a[4],
+    a[1]*b[4] + a[3]*b[5] + a[5]
+  ];
+}
+function matTranslate(tx,ty){ return [1,0,0,1,tx,ty]; }
+function matRotate(rad){
+  const s = Math.sin(rad), c = Math.cos(rad);
+  return [c, s, -s, c, 0, 0];
+}
+function matSkew(skewX, skewY){
+  return [1, Math.tan(skewY||0), Math.tan(skewX||0), 1, 0, 0];
+}
+function matScale(sx,sy){ return [sx,0,0,sy,0,0]; }
@@ ... @@
-function drawTile(ctx, t) {
-  ctx.save();
-  ctx.globalCompositeOperation = t.blend;
-  ctx.globalAlpha = t.opacity;
-  pathPoly(ctx, t.poly);
-  ctx.clip();
-  const b = polygonBBox(t.poly);
-  drawImageCover(ctx, t.src.img, b.x, b.y, b.w, b.h, t.src);
-  ctx.restore();
-}
+function drawTile(ctx, t) {
+  ctx.save();
+  ctx.globalCompositeOperation = t.blend;
+  ctx.globalAlpha = t.opacity;
+  // 1) Clip to the destination polygon
+  pathPoly(ctx, t.poly);
+  ctx.clip();
+  // 2) Draw the image with transform (rotation/skew/flip)
+  const b = polygonBBox(t.poly);
+  const cx = b.x + b.w/2, cy = b.y + b.h/2;
+  const skewX = t.skew || 0;
+  const skewY = (t.skewY != null) ? t.skewY : (Math.sign(skewX) * Math.abs(skewX) * 0.35);
+  let M = matIdentity();
+  M = matMultiply(M, matTranslate(cx, cy));
+  M = matMultiply(M, matRotate(t.angle || 0));
+  M = matMultiply(M, matSkew(skewX, skewY));
+  if (t.flipX || t.flipY) {
+    const sx = t.flipX ? -1 : 1, sy = t.flipY ? -1 : 1;
+    M = matMultiply(M, matScale(sx, sy));
+  }
+  M = matMultiply(M, matTranslate(-cx, -cy));
+  ctx.setTransform(M[0], M[1], M[2], M[3], M[4], M[5]);
+  // Expand draw rect for coverage after transform
+  const pad = Math.max(12, Math.min(b.w, b.h) * 0.08);
+  const dx = b.x - pad, dy = b.y - pad, dw = b.w + pad*2, dh = b.h + pad*2;
+  drawImageCover(ctx, t.src.img, dx, dy, dw, dh, t.src);
+  // Reset transform for strokes
+  ctx.setTransform(1,0,0,1,0,0);
+  // Emphasize edges for special shapes
+  if (t.type !== 'rect') {
+    ctx.save();
+    ctx.beginPath();
+    ctx.moveTo(t.poly[0].x, t.poly[0].y);
+    for (let i=1;i<t.poly.length;i++) ctx.lineTo(t.poly[i].x, t.poly[i].y);
+    ctx.closePath();
+    ctx.lineWidth = Math.max(1, Math.min(b.w, b.h) * 0.006);
+    ctx.strokeStyle = 'rgba(0,0,0,0.55)';
+    ctx.stroke();
+    ctx.globalCompositeOperation = 'overlay';
+    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
+    ctx.stroke();
+    ctx.globalCompositeOperation = 'source-over';
+    ctx.restore();
+  }
+  ctx.restore();
+}
@@ ... @@
-    const src = chooseCoverSample(img, bbox.w, bbox.h, R, { scale, overscan: 1.15 });
+    // Slightly larger overscan because image will be transformed in image space
+    const src = chooseCoverSample(img, bbox.w, bbox.h, R, { scale, overscan: 1.28 });
@@ ... @@
-      opacity: clamp(0.85 + R.range(-0.45, 0.15), 0.08, 1.0),
+      opacity: clamp(0.85 + R.range(-0.45, 0.15), 0.08, 1.0),
+      // flips help make pieces feel physically reoriented
+      flipX, flipY,
@@ ... @@
-      const src = chooseCoverSample(img, bbox.w, bbox.h, R, { scale, overscan: 1.12 });
+      const src = chooseCoverSample(img, bbox.w, bbox.h, R, { scale, overscan: 1.25 });
@@ ... @@
-      tiles.push({ kind:'tile', type:shapeType, poly, angle:rot, skew:sk, opacity: __clAlpha, src, blend:'source-over' });
+      tiles.push({ kind:'tile', type:shapeType, poly, angle:rot, skew:sk,
+        opacity: __clAlpha, src, blend:'source-over', flipX:fx, flipY:fy });
